options  {
  STATIC=false;
}  
PARSER_BEGIN(ConstructorAST)
package c_ast_descendente;

////////////////////////////////// mas import /////////////////////////////////////////////////////

import asint.TinyASint.Exp;
import asint.TinyASint.Dec;
import asint.TinyASint.Decs;
import asint.TinyASint.Prog;
import semops.SemOps;


public class ConstructorAST {
   private SemOps sem = new SemOps();
}
PARSER_END(ConstructorAST)
  TOKEN:{<#letra:["a"-"z","A"-"Z"]>}
  TOKEN:{<#digitoPositivo:["1"-"9"]>}
  TOKEN:{<#digito:<digitoPositivo>|"0">} 
  TOKEN:{<#parteEntera:<digitoPositivo> (<digito>)* |"0">} 
  TOKEN:{<#parteDecimal: ["."] ((<digito>)* <digitoPositivo> | "0")>}
  TOKEN:{<#parteExponencial: ["e", "E"] <litEnt>>}
  TOKEN:{<#signo: ["+","-"]>}
  SKIP:{<["\t"," ","\r","\b","\n"]>}  
  SKIP:{<"#"(~["\n"])*>}  
  TOKEN: {<AND:"and">}
  TOKEN: {<OR:"or">} 
  TOKEN: {<NOT:"not">}
  TOKEN: {<FALSE:"false">} 
  TOKEN: {<TRUE:"true">}
  TOKEN: {<INT:"int">} 
  TOKEN: {<REAL:"real">}
  TOKEN: {<STRING:"string">} 
  TOKEN: {<BOOL:"bool">}
  TOKEN: {<NULL:"null">} 
  TOKEN: {<PROC:"proc">}
  TOKEN: {<IF:"if">} 
  TOKEN: {<THEN:"then">}
  TOKEN: {<ELSE:"else">} 
  TOKEN: {<ENDIF:"endif">}
  TOKEN: {<WHILE:"while">} 
  TOKEN: {<DO:"do">}
  TOKEN: {<ENDWHILE:"endwhile">} 
  TOKEN: {<CALL:"call">}
  TOKEN: {<RECORD:"record">} 
  TOKEN: {<ARRAY:"array">}
  TOKEN: {<OF:"of">} 
  TOKEN: {<POINTER:"pointer">}
  TOKEN: {<NEW:"new">} 
  TOKEN: {<DELETE:"delete">}
  TOKEN: {<READ:"read">} 
  TOKEN: {<WRITE:"write">}
  TOKEN: {<NL:"nl">} 
  TOKEN: {<VAR:"var">}
  TOKEN: {<TYPE:"type">}
  TOKEN: {<comillas:"\"">}
  TOKEN: {<litCad:<comillas>(~["\"","\r","\b","\n"])*<comillas>>}
  TOKEN: {<identificador:<letra>(<letra>|<digito>|"_")*>}
  TOKEN: {<litEnt: (<signo>)? <parteEntera> >}
  TOKEN: {<litReal: <litEnt> (<parteDecimal> | <parteExponencial> | <parteDecimal> <parteExponencial>)>  }
  
  
  Prog PROGRAMAp()    : {Prog prog;} {prog=PROGRAMA() <EOF> {return prog;}}
  Prog PROGRAMA()    : {Exp exp; Decs decs;}
  						{decs=DECLARACIONES() "&&" ins=INSTRUCCIONES() {return sem.P_decs(exp,decs,ins);} | ins=INSTRUCCIONES() {return sem.P_nodecs(exp,ins);}}
  




  Decs DECLARACIONES()  : {Decs decs;} 
                       {dec=DECLARACION() decs = RDECLARACIONES(sem.decsuna(dec)) {return decs;}}
 
  Decs RDECLARACIONES(Dec dec_h)    : {Dec dec; Decs decs;} {";" dec = DECLARACION() decs = RDECLARACIONES(sem.decsmuchas(dec,dec_h)) {return decs;} | {return null;} }
  Decs DECLARACION()    : {Dec dec;} {dec = DECVAR() {return dec;}| dec = DECTIPO() {return dec;} | dec = DECPROC() {return dec;} }

 




  Dec DECVAR()    : {Token v, iden; TIPO tipo;} {v=<VAR> tipo = TIPO() iden=<identificador> {return sem.tipo(sem.str(iden.image,iden.beginLine,iden.beginColumn), 
  																						    tipo, sem.str(v.image,v.beginLine,v.beginColumn));}}
  Dec DECTIPO()    : {Token t, iden; TIPO tipo;} {t=<TYPE> tipo = TIPO() iden=<identificador> {return sem.tipo(sem.str(iden.image,iden.beginLine,iden.beginColumn), 
  																						    tipo, sem.str(t.image,t.beginLine,t.beginColumn));}}
  Dec DECPROC()    : {Token p, iden; Pforms pforms; B bl;} {p=<PROC> iden=<identificador> pforms = PFORMALES() bl = BLOQUE(){return sem.proc(sem.str(p.image,p.beginLine,p.beginColumn),
  																												sem.str(iden.image,iden.beginLine,iden.beginColumn), 
  																						    					pforms, bl);}}
 




  Pforms PFORMALES()    : {Pforms pforms;} 
  						  { "(" pforms = RPFORMALES() {return pforms;}}
  						  
  Pforms RPFORMALES() : {Pforms pforms;} 
  						{ pforms = LISTA_PFORMALES() ")" {return pforms;} | ")" {return null;} }
  						
  Pforms LISTA_PFORMALES()    : {Pforms pforms; Pform pform;} 
  								{pform = PFORMAL() pforms = RLISTA_PFORMALES(sem.pformal_uno(pform)) {return pforms;}}

  Pforms RLISTA_PFORMALES(Pforms pforms)    : {Pforms pforms; Pform pform;}
  												{"," pform = PFORMAL() pformsr = RLISTA_PFORMALES(sem.pformal_muchas(pform, pforms)) {return pformsr;} | {return null;} }





  Pform PFORMAL()    : {TIPO t; Pform rpf;}
						{t=TIPO() rpf =RPFORMAL() {return sem.tipo_formal(t,rpf);}}
  Pform RPFORMAL() : {Token id;}
  						{"&" id=<identificador> {return sem.str(id.image,id.beginLine,id.beginColumn);} | id=<identificador> {return sem.str(id.image,id.beginLine,id.beginColumn);}}






  TIPO TIPO()    : {TIPO tb, t; Token id, le; CAMPS l;}
				   {tb = TIPO_BASICO() {return tb;}|
				    id=<identificador> {return sem.str(id.image,id.beginLine,id.beginColumn);} |
				    <ARRAY> "[" le=<litEnt> "]" <OF> t = TIPO() {return sem.array(sem.str(le.image,le.beginLine,le.beginColumn), t);}|
				    <RECORD> "{" l=LISTA_CAMPOS() "}" {return sem.listacampostipo(l);}|
				    <POINTER> t=TIPO() {return sem.pointer(t);}}
				    
  TIPO TIPO_BASICO()    : {Token i, r, b, s;}
						  {i=<INT> {return sem.tipo(sem.str(i.image,i.beginLine,i.beginColumn));}|
						   r=<REAL> {return sem.tipo(sem.str(r.image,r.beginLine,r.beginColumn));}|
						   b=<BOOL> {return sem.tipo(sem.str(b.image,b.beginLine,b.beginColumn));}|
						   s=<STRING> {return sem.tipo(sem.str(s.image,s.beginLine,s.beginColumn));}}








  CAMPS LISTA_CAMPOS()    : {CAMP c; CAMPS rl;}
							{c=CAMPO() rl = RLISTA_CAMPOS(sem.campo_una(c)) {return rl;}}

  CAMPS RLISTA_CAMPOS(CAMPS campos)    : {CAMP c; CAMPS rl;}
										{";" c=CAMPO() rl = RLISTA_CAMPOS(sem.campo_muchos(c, campos)) {return rl;} | {return null;} }

  CAMP CAMPO()    : {TIPO t; Token id;}
					{t=TIPO() id=<identificador> {return sem.campo(t,sem.str(id.image,id.beginLine,id.beginColumn));}}





  INS INSTRUCCIONES()    : {In in; Ins ins;}
  							{in=INSTRUCCION() ins=RINST(sem.ins_una(in)) {return ins;}}
  							
  INS RINST(Ins instruc)    : {In in; Ins ins;}
								{";" in=INSTRUCCION() ins=RINST(sem.ins_muchas(in, instruc)) | {return ins;}}
  
  IN INSTRUCCION()    : {EX ex, ex1, ex2; INS rif, l_ins; Token id; EXS l_exp; B b;}
						{ ex1=EXPRESION() "=" ex2=EXPRESION() {return sem.asig(ex1,ex2);}|
						 <IF> ex=EXPRESION() <THEN> l_ins=LISTA_INST_OP() rif=RIFTHEN() <ENDIF> {return sem.if(ex,l_ins,rif);}|
  					     <WHILE> ex=EXPRESION() <DO> l_ins=LISTA_INST_OP()  <ENDWHILE> {return sem.while(ex,l_ins);}|
  					     <READ> ex=EXPRESION() {return sem.read(ex);}|
  					     <WRITE> ex=EXPRESION() {return sem.write(ex);}|
  					     <NL> {return sem.nl();}|
  					     <NEW> ex=EXPRESION() {return sem.new(ex);}|
  						 <DELETE> ex=EXPRESION() {return sem.delete(ex);}|
  						 <CALL> id=<identificador> "(" l_exp=LISTA_EXPR_OP() ")" {return sem.call(str(id.image,id.beginLine,id.beginColumn),l_exp);}|
  						 b=BLOQUE() {return b;}}






  INS LISTA_INST_OP()    : {INS l;}
							{l=LISTA_INST() {return l;} | {return null;} }

  INS LISTA_INST()    : {IN in; INS ins;}
						{in=INSTRUCCION() ins=RLISTA_INST(sem.ins_una(in)) {return ins;}}

  INS RLISTA_INST(INS instrucs)    : {IN in; INS ins;}
									 {";" in=INSTRUCCION() ins=RLISTA_INST(sem.ins_muchas(in, instrucs)) {return ins; } | {return null;}}  

  INS RIFTHEN()    : {INS ins;}
					{<ELSE> ins=LISTA_INST() {return ins;} | {return null;}}


  




  EXS LISTA_EXPR_OP()    : {EXS exs;}
							{exs=LISTA_EXPR() {return exs;} | {return null;}}  

  EXS LISTA_EXPR()    : {EX ex; EXS exs;}
						{ex=EXPRESION() exs=RLISTA_EXPR(sem.exs_una(ex)) {return exs}}

  EXS RLISTA_EXPR(EXS expres)    : {EX ex; EXS exs;}
									{"," ex=EXPRESION() exs=RLISTA_EXPR(sem.exs_muchas(ex,expres)) {return exs;} | {return null;}}
  






  B BLOQUE()    : {B b;}
				  { "{" b=RBLOQUE() {return b;} }

  B RBLOQUE() : {B p;}
				{ p=PROGRAMA() "}" {return p;} | "}" {return sem.no_exp();}} 
  






  EX EXPRESION()    : {EX ex;}
					  { ex=E0() {return ex;} }
					
  EX EXPRESION_BASICA()    : {Token t;}
							{t=<TRUE> {return sem.ex(sem.str(t.image,t.beginLine,t.beginColumn));}|
							 t=<FALSE> {return sem.ex(sem.str(t.image,t.beginLine,t.beginColumn));}|
							 t=<identificador> {return sem.ex(sem.str(t.image,t.beginLine,t.beginColumn));}|
							 t=<NULL> {return sem.ex(sem.str(t.image,t.beginLine,t.beginColumn));}|
							 t=<litEnt> {return sem.ex(sem.str(t.image,t.beginLine,t.beginColumn));}|
							 t=<litReal> {return sem.ex(sem.str(t.image,t.beginLine,t.beginColumn));}|
							 t=<litCad> {return sem.ex(sem.str(t.image,t.beginLine,t.beginColumn));}}
  


  EX E0()       : {EX exp, resul;} {exp=E1() resul=RE0(exp) {return resul;}}
  EX RE0(EX exph) : {EX exp;} 
                       {"+" exp=E0() {return sem.suma(exp,exph);} |
                       {"-" exp=E1() {return sem.resta(exp,exph);} |
                       {return exph;}}
                   
  
  
  EX E1()   : {EX exp, resul;} {exp=E2() resul=RE1(exp) {return resul;}}
  EX RE1(EX exph)  : {char op; EX exp, resul;}
						{op=OPBN1() exp=E2() resul=RE1(sem.exp(op,exph,exp)) {return resul}|
						{return exph;} }


  
  EX E2()   : {EX exp, resul;} {exp=E3() resul=RE2(exp) {return resul;}}
  EX RE2(EX exph)  : {char op; EX exp, resul;}
						{op=OPBN2() exp=E3() RE2(sem.exp(op,exph,exp)) {return resul}|
						{return exph;} }

						
  
  EX E3()   : {EX exp, resul;} {exp=E4() resul=RE3(exp) {return resul;}}
  EX RE3(EX exph)  : {char op; EX exp, resul;}
  						{op=OPBN3() exp=E4() {return sem.exp(op,exph,exp);} |
  						{return exph;} }
  						
  
  EX E4()   : {EX resul;}
  				{<NOT> resul=E4() {return sem.not(exp);}|
  				 "-" resul=E5() {return sem.neg(exp);;}|
  				  resul=E5() {return resul;}}
  
  EX E5()	  : {EX exp, resul;} {exp=E6() resul=RE5(exp) {return resul;}}
  EX RE5(EX exph)  : {EX op, exp;}
						{op=OPUN5() exp=RE5() {return sem.expN5(op,exph,exp);} |
						{return exph;}}

  EX E6()   : {EX exp;} {"*" exp=E6() {return sem.star(exp);} | exp=E7() {return exp;}}
  EX E7()   : {EX exp;} {exp=EXPRESION_BASICA() {return exp;} | "(" exp=E0() ")" {return exp;}} 
  
  char OPBN1()  : {} {<AND> {return 'a';} | <OR> {return 'o';}}
  char OPBN2()  : {} {"<" {return '<';} | ">" {return ' >';} | "<=" {return '<=';}| ">=" {return ' >=';} | "==" {return '==';}| "!=" {return '!=';}}
  char OPBN3()  : {} {"*" {return '*';} | "/" {return '/';}| "%" {return '%';}}
  EX OPUN5()  : {EX exp;} {"[" exp=EXPRESION() "]" {return exp;} | exp=OP_ACCESO() {return exp;}}
  
  EX OP_ACCESO()  : {Token iden;} {"." iden=<identificador> {return sem.flecha(sem.str(iden.image,iden.beginLine,iden.beginColumn))}| "->" iden=<identificador> {return sem.flecha(sem.str(iden.image,iden.beginLine,iden.beginColumn))}}


