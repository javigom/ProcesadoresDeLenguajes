package c_ast_ascendente;


import java_cup.runtime.*;
import semops.SemOps;
import asint.TinyASint.Exp;
import asint.TinyASint.Exps;
import asint.TinyASint.Declaracion;
import asint.TinyASint.Declaraciones;
import asint.TinyASint.Instruccion;
import asint.TinyASint.Instrucciones;
import asint.TinyASint.Camps;
import asint.TinyASint.Camp;
import asint.TinyASint.Tipo;
import asint.TinyASint.Bloque;
import asint.TinyASint.ParamForms;
import asint.TinyASint.ParamForm;
import asint.TinyASint.Programa;
import asint.TinyASint.StringLocalizado;


scan with {: return getScanner().next_token(); :};
action code {:
   private SemOps sem = new SemOps();
:};
parser code {: 
   private GestionErrores errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErrores();
   AnalizadorLexico alex = (AnalizadorLexico)getScanner();
   alex.fijaGestionErrores(errores);
:};





terminal 	 MAS, MENOS, DIV, POR, PERCENT, AND, NOT, OR, MENOR, 
			 MAYOR, MENOR_IGUAL, MAYOR_IGUAL, IGUAL, DIF, PAP, PCIERRE, CAP, 
			 CCIERRE, PUNTO, FLECHA, DAMP, PCOMA, VAR, ID, TYPE, 
			 PROC, COMA, AMP, TRUE, FALSE, LIT_ENT, LIT_REAL, LIT_CAD,
			 NULL, ARRAY, OF, RECORD, LLAP, LLCIERRE, POINTER,
			 INT, BOOL, REAL, STRING, IF, THEN, ELSE, WHILE, ENDIF, DO,
			 ENDWHILE, READ, NL, DELETE, NEW, WRITE, CALL, DIGUAL;
			 
terminal StringLocalizado NUM, ID;





non terminal  Programa PROGRAMA;

non terminal  Declaraciones DECLARACIONES;
non terminal  Declaracion DECLARACION, DECVAR, DECTIPO, DECPROC;

non terminal  Instrucciones INSTRUCCIONES, LISTA_INST, LISTA_INST_OP;
non terminal  Instruccion INSTRUCCION;

non terminal  Tipo TIPO, TIPO_BASICO;

non terminal  ParamForms PFORMALES, LISTA_PFORMALES;
non terminal  ParamForm PFORMAL;

non terminal  Camps LISTA_CAMPOS;
non terminal  Camp CAMPO;

non terminal Bloque BLOQUE;

non terminal  Exps LISTA_EXPR_OP, LISTA_EXPR;
non terminal  Exp E0, E1, E2, E3, E4, E5, E6, E7, OPUN5, EXPRESION_BASICA,
			  EXPRESION, OP_ACCESO;
			  
non terminal  String OPBN1, OPBN2, OPBN3;









Prog ::= EVALUA E0: exp PDonde: decs 
    {: RESULT = sem.prog(exp,decs);:};
PDonde ::= DONDE Decs: decs 
    {: RESULT = decs;:};
PDonde ::= {: RESULT = null; :};
E0 ::= E0: arg0  OP0: op E1: arg1  
    {: RESULT = sem.exp(op,arg0,arg1); :};
E0 ::= E1: aDeE1 
    {: RESULT = aDeE1; :};
E1 ::= E1: arg0 OP1: op E2: arg1 
    {: RESULT = sem.exp(op,arg0,arg1); :};
E1 ::= E2: aDeE2 
    {: RESULT = aDeE2; :};
E2 ::= NUM:  num 
    {: RESULT = sem.num(num); :};
E2 ::= ID:id 
    {: RESULT = sem.id(id); :};
E2 ::= PAP E0: aDeE0 PCIERRE 
    {: RESULT = aDeE0; :};
OP0 ::= MAS 
    {: RESULT = '+'; :};
OP0 ::= MENOS 
    {:RESULT = '-'; :};
OP1 ::= POR 
    {: RESULT = '*'; :};
OP1 ::= DIV 
    {: RESULT = '/'; :};
Decs ::= Decs: decs COMA Dec: dec 
    {: RESULT = sem.decs_muchas(decs,dec);:};
Decs ::= Dec: dec 
    {: RESULT = sem.decs_una(dec);:};
Dec ::= ID: id IGUAL NUM: num 
    {: RESULT = sem.dec(id,num); :};


